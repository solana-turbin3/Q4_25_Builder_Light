### To create a vault on solana (native SOL vault)
Start by defining a VaultState to store bumps and the vault's state
```
    // an anchor macro for calculating required space
    #[derive(InitSpace)]
    #[account]
    pub struct VaultState {
        pub vault_bump: u8,
        pub state_bump: u8,
    }
```

Confusing part. Vault and State bumps
VaultState is the metadata account that stores all information the program needs to rebuild or reference the vault later. It is used when declaring vault_state accounts.
It holds:- vault_bump: the bump seed used to derive the vault PDA & state_bump: the bump seed used to derive the VaultState PDA itself

When we derive vauld and state PDA in the client side i.e
```
const [vaultStatePda, stateBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("state"), user.toBuffer()],
    program.programId
  );

  const [vaultPda, vaultBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), vaultStatePda.toBuffer()],
    program.programId
  );
```

The bumps are passed automatically by anchor as &InitializeBumps (via ctx.bumps)
What is ctx.bumps and &InitializeBumps?
- Whenever we use bump when definingn account in Anchor, here’s what happens under the hood:
- Anchor looks at the seeds you declared ([b"state", user.key().as_ref()] etc.).
- It calls the Solana runtime’s find_program_address using those exact seeds and your program’s ID.
- It figures out what the PDA and bump should be.
- It verifies that the PDA you passed from the client matches the one derived on-chain.
- If the PDA is valid, it stores the bump internally in a hidden struct called ctx.bumps.
- &InitializeBumps is auto-generated by Anchor whenever we use #[derive(Accounts)]
- For our initialize for example it generates:
```
pub struct InitializeBumps {
    pub vault: u8,
    pub vault_state: u8,
}
```
which is why we can access it using bumps(i.e &InitializeBumps).vault|vault_state

Why we use VaultState at all rather than allowing user be the vault signer?: the vault would be user-controlled, not program-controlled, the user could withdraw anytime, even outside the program’s logic. By making the vault state the signer user can only deposit into the vault, only the program via vault_state authority(signerseeds) can withdraw from it because although the vault state is generated using the user key it is stilla PDA account owned by the program only.



To initialize the vault, we start by defining its accounts
*vault_state: to store the bumps(Why?: )
*vault: a SystemAccountPDA meaning it holds no data and is only useful for storing lamports, no init because it is initialized automatically at initialization when we transfer lamports to it
*user(signer, pays for vault_state init also) and system_program

We then define an impementation(impl) for initialize
- get rent exempt amount
- make a cpi invocation to the system program to transfer lamports (rent exempt amount) from the user to the vault.
- store ...

Now the vault has been initialized and its state stored, we proceed to Deposit
- Accounts needed: user, vault(mut), vault_state(no-init), sys program
- impl: take _amount as an input, then make a invoke a cpi to transfer _amount to the vault from the user;

To withdraw
- Same accounts as deposit.
- then we make a cpi invocation to transfer _amount from the vault to the user
- vault is owned by SystemProgram so we need to make the cpi context so we need to generate signer seeds that reproduce the PDA derivation
- add with_signer(signer_seeds) to the CpiContext. then execute the transfer

Close Instruction (empties the vault and transfers its lamport balance to user)
- identical to withdraw but we modify the vault_state to be mutable and add a close=user attribute (which tells Anchor to send the rent-exempt lamports from vault_state back to the user when it’s closed.).
- in the transfer instruction, we transfer self.vault.lamports() which sends the entire vault's balance.







